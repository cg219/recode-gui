// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package recode

import (
	"context"
	"database/sql"
)

const createRecode = `-- name: CreateRecode :exec
INSERT INTO recodes (season, episode, dest, origin)
VALUES (?, ?, ?, ?)
`

type CreateRecodeParams struct {
	Season  string
	Episode string
	Dest    string
	Origin  string
}

func (q *Queries) CreateRecode(ctx context.Context, arg CreateRecodeParams) error {
	_, err := q.db.ExecContext(ctx, createRecode,
		arg.Season,
		arg.Episode,
		arg.Dest,
		arg.Origin,
	)
	return err
}

const getPrefs = `-- name: GetPrefs :one
SELECT rootdir
FROM prefs
`

func (q *Queries) GetPrefs(ctx context.Context) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getPrefs)
	var rootdir sql.NullString
	err := row.Scan(&rootdir)
	return rootdir, err
}

const getQueue = `-- name: GetQueue :many
SELECT origin, dest, season, episode
FROM recodes
WHERE processed = 0
`

type GetQueueRow struct {
	Origin  string
	Dest    string
	Season  string
	Episode string
}

func (q *Queries) GetQueue(ctx context.Context) ([]GetQueueRow, error) {
	rows, err := q.db.QueryContext(ctx, getQueue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQueueRow
	for rows.Next() {
		var i GetQueueRow
		if err := rows.Scan(
			&i.Origin,
			&i.Dest,
			&i.Season,
			&i.Episode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePref = `-- name: UpdatePref :exec
INSERT INTO prefs (id, rootdir)
VALUES (?, ?)
ON CONFLICT (id)
DO UPDATE SET rootdir = excluded.rootdir
`

type UpdatePrefParams struct {
	ID      int64
	Rootdir sql.NullString
}

func (q *Queries) UpdatePref(ctx context.Context, arg UpdatePrefParams) error {
	_, err := q.db.ExecContext(ctx, updatePref, arg.ID, arg.Rootdir)
	return err
}
